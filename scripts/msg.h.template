@###############################################
@#
@# ROS message source code generation for C++
@#
@# EmPy template for generating <msg>.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@###############################################
// Generated by gencpp from file @(spec.package)/@(spec.short_name).msg
// DO NOT EDIT!

@{
from collections import OrderedDict
import genmsg.msgs
import gencpp
import os

cpp_namespace = '::%s::'%(spec.package) # TODO handle nested namespace
cpp_class = '%s_'%spec.short_name
cpp_full_name = '%s%s'%(cpp_namespace,cpp_class)
cpp_full_name_with_alloc = '%s<ContainerAllocator>'%(cpp_full_name)
cpp_full_name_with_comp_alloc1 = '%s<ContainerAllocator1>'%(cpp_full_name)
cpp_full_name_with_comp_alloc2 = '%s<ContainerAllocator2>'%(cpp_full_name)
cpp_msg_definition = gencpp.escape_message_definition(msg_definition)
has_plugin = os.path.exists('include/%s/plugin/%s.h' % (spec.package, spec.short_name))
has_plugin_after = os.path.exists('include/%s/plugin/%s.after.h' % (spec.package, spec.short_name))
}@

#ifndef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
#define @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H

@##############################
@# Generic Includes
@##############################

#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

@##############################
@# Includes for dependencies
@##############################
@{
for field in spec.parsed_fields():
  if (not field.is_builtin):
    if (field.is_header):
      print('#include <std_msgs/Header.h>')
    else:
      (package, name) = genmsg.names.package_resource_name(field.base_type)
      package = package or spec.package # convert '' to package
      print('#include <%s/%s.h>'%(package, name))
}@
@##############################
@# Plugin
@##############################
@[if has_plugin]@
#include <@(spec.package)/plugin/@(spec.short_name).h>
@[end if]@

namespace @(spec.package)
{
template <class ContainerAllocator>
struct @(spec.short_name)_
{
  typedef @(spec.short_name)_<ContainerAllocator> Type;

@# constructors (with and without allocator)
@[if has_plugin]@
#ifdef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_CONSTRUCTOR
  @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_CONSTRUCTOR
#else
@[end if]@
@[for (alloc_type,alloc_name) in [['',''],['const ContainerAllocator& ','_alloc']]]@
  @(spec.short_name)_(@(alloc_type+alloc_name))
@# Write initializer list
  @('\n  '.join(gencpp.generate_initializer_list(spec, alloc_name != '' )))@
  {
@# Fixed length arrays
@[if alloc_name != '' and not [f for f in spec.parsed_fields() if f.is_array and f.array_len is not None and f.base_type == 'string']]@
  (void)_alloc;
@[end if]@
  @('\n  '.join(gencpp.generate_fixed_length_assigns(spec, alloc_name != '', '%s::'%(spec.package))))@
  }
@[end for]
@[if has_plugin]@
#endif
@[end if]@

@[for field in spec.parsed_fields()]
 @{cpp_type = gencpp.msg_type_to_cpp(field.type)}@
  typedef @(cpp_type) _@(field.name)_type;
  _@(field.name)_type @(field.name);
@[end for]

@# Constants
@{
constants_integer = []
constants_non_integer = []
for constant in spec.constants:
  if constant.type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']:
    constants_integer.append(constant)
  else:
    constants_non_integer.append(constant)
}@

@[if len(spec.constants) > 0]@
// reducing the odds to have name collisions with Windows.h 
@[for constant in spec.constants]@
#if defined(_WIN32) && defined(@(constant.name))
  #undef @(constant.name)
#endif
@[end for]@

@[end if]@
@# Integer constants
@[if len(constants_integer) > 0]@
  enum {
@[for constant in constants_integer]@
@[if (constant.type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char'])]@
    @(constant.name) = @(int(constant.val)),
@[elif (constant.type in ['uint8', 'uint16', 'uint32', 'uint64'])]@
    @(constant.name) = @(int(constant.val))u,
@[end if]@
@[end for]@
  };
@[end if]@

@# Non-integer constants
@[for constant in constants_non_integer]@
  static const @(gencpp.msg_type_to_cpp(constant.type)) @(constant.name);
@[end for]@

@# Shared pointer typedefs
  typedef boost::shared_ptr< @(cpp_full_name)<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< @(cpp_full_name)<ContainerAllocator> const> ConstPtr;

@# Class body extensions provided by plugin
@[if has_plugin]@
#ifdef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_CLASS_BODY
  @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_CLASS_BODY
#endif
@[end if]@
}; // struct @(cpp_class)

@# Typedef of template instance using std::allocator
typedef @(cpp_full_name)<std::allocator<void> > @(spec.short_name);

@# Shared pointer typedefs
typedef boost::shared_ptr< @(cpp_namespace+spec.short_name) > @(spec.short_name)Ptr;
typedef boost::shared_ptr< @(cpp_namespace+spec.short_name) const> @(spec.short_name)ConstPtr;

// constants requiring out of line definition
@[for c in spec.constants]
   @[if c.type not in ['byte', 'int8', 'int16', 'int32', 'int64', 'char', 'uint8', 'uint16', 'uint32', 'uint64']]
   template<typename ContainerAllocator> const @(gencpp.msg_type_to_cpp(c.type))
      @(spec.short_name)_<ContainerAllocator>::@(c.name) =
        @[if c.type == 'string']
          "@(gencpp.escape_string(c.val))"
        @[elif c.type == 'bool']
           @(int(c.val))
        @[else]
          @c.val
        @[end if]
        ;
   @[end if]
@[end for]


@# Printer
template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const @(cpp_full_name_with_alloc) & v)
{
ros::message_operations::Printer< @(cpp_full_name_with_alloc) >::stream(s, "", v);
return s;
}

@[if len(spec.parsed_fields()) > 0]
@# Equality
template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const @(cpp_full_name_with_comp_alloc1) & lhs, const @(cpp_full_name_with_comp_alloc2) & rhs)
{
  return @
@[for i, field in enumerate(spec.parsed_fields())]@
@[if i != 0]@
 &&
    @
@[end if]@
lhs.@(field.name) == rhs.@(field.name)@
@[end for]@
;
}

@# Inequality
template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const @(cpp_full_name_with_comp_alloc1) & lhs, const @(cpp_full_name_with_comp_alloc2) & rhs)
{
  return !(lhs == rhs);
}

@[end if]
@# End of namespace
} // namespace @(spec.package)

@# Message Traits
namespace ros
{
namespace message_traits
{

@{
bool_traits = OrderedDict(
    IsMessage=True,
    IsFixedSize=gencpp.is_fixed_length(spec, msg_context, search_path),
    HasHeader=spec.has_header(),
)
def booltotype(b):
   return "TrueType" if b else "FalseType"
}

@# Binary traits

@[for k, v in bool_traits.items()]@

template <class ContainerAllocator>
struct @(k)< @(cpp_full_name_with_alloc) >
  : @(booltotype(v))
  { };

template <class ContainerAllocator>
struct @(k)< @(cpp_full_name_with_alloc) const>
  : @(booltotype(v))
  { };
@[end for]@

@# String traits
@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', spec.full_name], ['Definition', cpp_msg_definition]]]@

template<class ContainerAllocator>
struct @(trait_class)< @(cpp_full_name_with_alloc) >
{
  static const char* value()
  {
@[if trait_class == 'Definition']@
    return @(trait_value);
@[else]@
    return "@(trait_value)";
@[end if]@
  }

  static const char* value(const @(cpp_full_name_with_alloc)&) { return value(); }
@{
if trait_class == 'MD5Sum':
  iter_count = int(len(trait_value) / 16)
  for i in range(0, iter_count):
    start = i*16
    print('  static const uint64_t static_value%s = 0x%sULL;'%((i+1), trait_value[start:start+16]))
}@
};
@[end for]@

@# End of traits
} // namespace message_traits
} // namespace ros

@# Serialization
namespace ros
{
namespace serialization
{

@[if has_plugin]@
#ifdef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_SERIALIZER
  @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_SERIALIZER
#else
@[end if]@
  template<class ContainerAllocator> struct Serializer< @(cpp_full_name_with_alloc) >
  {
@[if spec.parsed_fields()]@
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
@[for field in spec.parsed_fields()]@
      stream.next(m.@(field.name));
@[end for]@
    }
@[else]@
    template<typename Stream, typename T> inline static void allInOne(Stream&, T)
    {}
@[end if]@

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct @(cpp_class)
@[if has_plugin]@
#endif
@[end if]@

} // namespace serialization
} // namespace ros

@# Message Operations
namespace ros
{
namespace message_operations
{

@# Printer operation
@[if has_plugin]@
#ifdef @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_PRINTER
  @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_PLUGIN_PRINTER
#else
@[end if]@
template<class ContainerAllocator>
struct Printer< @(cpp_full_name_with_alloc) >
{
@[if spec.parsed_fields()]@
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const @(cpp_full_name_with_alloc)& v)
  {
@# todo, change this stuff below into proper EmPy syntax
@{
for field in spec.parsed_fields():
  cpp_type = gencpp.msg_type_to_cpp(field.base_type)
  if (field.is_array):
    print('    s << indent << "%s[]" << std::endl;'%(field.name))
    print('    for (size_t i = 0; i < v.%s.size(); ++i)'%(field.name))
    print('    {')
    print('      s << indent << "  %s[" << i << "]: ";'%(field.name))
    indent_increment = '  '
    if (not field.is_builtin):
      print('      s << std::endl;')
      print('      s << indent;')
      indent_increment = '    ';
    print('      Printer<%s>::stream(s, indent + "%s", v.%s[i]);'%(cpp_type, indent_increment, field.name))
    print('    }')
  else:
    print('    s << indent << "%s: ";'%(field.name))
    indent_increment = '  '
    if (not field.is_builtin or field.is_array):
      print('    s << std::endl;')
    print('    Printer<%s>::stream(s, indent + "%s", v.%s);'%(cpp_type, indent_increment, field.name))
}@
  }
@[else]@
  template<typename Stream> static void stream(Stream&, const std::string&, const @(cpp_full_name_with_alloc)&)
  {}
@[end if]@
};
@[if has_plugin]@
#endif
@[end if]@

} // namespace message_operations
} // namespace ros

@# Free function extensions provided by plugin
@[if has_plugin_after]@
#include <@(spec.package)/plugin/@(spec.short_name).after.h>

@[end if]@
#endif // @(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_H
